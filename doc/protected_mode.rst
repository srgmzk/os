Protected mode
==============

o Protected 32bit mode - First implementation Intel 80386 
o Способ получения начального адреса сегмента изменился по сравнению с реальным.

в реальном: Linear address = segment base* 16 + offset // - convert 16 bit -> 20 bit addr bus
в защищенном: Linear address = segment base(taken from system table) + offset

o Каждый из сегментных регистров cs, ds, ss, es, gs, fs хранит т.н. *сегментный селектор*
o Сегментный селектор содержит индекс в специальной таблице дескрипторов сегмента и еще доп.  информацию.
o Два типа: 
    > LDT
        - много таблиц реализованных hw
        - не используется, не адаптирована производителями OS
        - вместо этого, для изоляции используется виртуальная память
    > GDT
        - Для храниения адреса и размера используется регистр GDTR

        Сегментный селектор:
        15           3 2  1    0
        +------------+---+-----+
        |   Index    | T | RPL |
        +------------+---+-----+
        
        - Index denotes descriptor position in either GDT or LDT. The T bit selects either LDT or GDT.
          As LDTs are no longer used, it will be zero in all cases.
        - RPL - Request Privilege Level - It's value against Descriptor Privelege Level (stored in 
          descriptor table) is performed. Если RPL недостаточно привилигирован для доступа к сегменту,
          произойдет ошибка. 
        - Privilege levels are the same thing as protection rings
        
        > ss или cs однозначно содержат ( в двух младших битах ) текущий уровень привелегий ( текущее 
          кольцо ) . 


Это то, что влияет на возможность выполнения определенных критических инструкций.
(например, изменение самого GDT). Легко сделать вывод, что для ds изменение этих битов позволяет 
нам переопределить текущий уровень привилегий, сделав его менее привилегированным специально для доступа к данным в выбранном сегменте. Например, сейчас мы находимся в ring0 и ds = 0x02. Даже если два младших бита cs и ss равны 0 (поскольку мы находимся внутри кольца ring0), мы не можем получить доступ к данным в сегменте с уровнем привилегий выше 2 (например, 1 или 0). Другими словами, поле RPL хранит, насколько мы привилегированы при запросе доступа к сегменту. Сегменты, в свою очередь, назначаются одному из четырех колец защиты. При запросе доступа с определенным уровнем привилегий уровень привилегий должен быть выше, чем уровень привилегий, присвоенный самому сегменту. 

You can’t change cs directly.!!!!

Вы можете подумать, что каждая транзакция памяти теперь нуждается в другой для чтения содержимого GDT. Это неверно: для каждого сегментного регистра существует так называемый теневой регистр, на который нельзя напрямую ссылаться. Он служит кешем для содержимого GDT. Это означает, что после изменения селектора сегмента в соответствующий теневой регистр загружается соответствующий дескриптор из GDT. Теперь этот регистр будет служить источником всей необходимой информации об этом сегменте. 

Как видите, сегментация - довольно громоздкое зверюга. Есть причины, по которым он не был широко принят ни операционными системами, ни программистами (и теперь в значительной степени заброшен). • Программистам не проще сделать сегментацию; • Ни один из широко используемых языков программирования не включает сегментацию в свою модель памяти. Это всегда плоская память. Таким образом, задача компилятора - создавать сегменты (что сложно реализовать). • Сегменты делают фрагментацию памяти катастрофой. • Таблица дескрипторов может содержать до 8192 дескрипторов сегментов. Как мы можем эффективно использовать это небольшое количество? После введения длительного режима сегментация была очищена от процессора, но не полностью. Он по-прежнему используется для защитных колец, и поэтому программист должен это понимать.v
          
        
